#as builder создаёт именованный этап сборки, который дальше можно использовать (--from=builder).
#Этот образ содержит инструменты Go (go, gcc, и т.д.) — всё нужное для сборки кода.
FROM golang:1.23-alpine as builder

# Внутри контейнера создаётся директория /app, куда поместим исходники и будем собирать приложение.
RUN mkdir /app

# Копирует все файлы из текущей директории (где находится Dockerfile) в /app внутри контейнера.
COPY  . /app

# Меняет текущую рабочую директорию на /app.
# После этого все команды (RUN, CMD, COPY, ADD) выполняются относительно /app.
WORKDIR /app

# CGO_ENABLED=0 — отключает использование C-библиотек (чистый Go-бинарник).
# Это важно, потому что финальный образ (Alpine) может не содержать glibc, и тогда бинарник должен быть статически слинкован.
# go build -o brokerApp ./cmd/api — компилирует исходники из каталога ./cmd/api в исполняемый файл /app/brokerApp.
RUN CGO_ENABLED=0 go build -o brokerApp ./cmd/api

# Меняет права доступа, чтобы файл brokerApp стал исполняемым.
# Иногда это не обязательно, но бывает нужно, если система файлов копировала файл без флага +x.
RUN chmod +x /app/brokerApp

# Начинается новый этап сборки (вторая стадия).
# Используется свежий образ alpine:latest — это очень лёгкий Linux-дистрибутив (~5 MB).
# В нём нет Go, компилятора и прочего мусора, только минимальные системные библиотеки.
# Это сильно уменьшает размер итогового образа.
FROM alpine:latest

# Создаёт пустую директорию /app в финальном контейнере, куда мы поместим наш бинарник.
RUN mkdir /app

# Копирует файл brokerApp из первой стадии (builder) в текущую директорию /app финального образа.
# Благодаря --from=builder мы не переносим весь код, зависимости и Go-компилятор, а только один бинарник.
COPY --from=builder /app/brokerApp /app

# Определяет команду, которая запускается по умолчанию, когда контейнер стартует.
# В данном случае запускается бинарник /app/brokerApp.
# То есть при docker run контейнер сразу запускает твоё Go-приложение.
CMD [ "/app/brokerApp" ]